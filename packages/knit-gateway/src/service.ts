// Copyright 2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import {
  Code,
  ConnectError,
  type ServiceImpl,
  type Transport,
} from "@bufbuild/connect";
import { createAsyncIterable, pipe } from "@bufbuild/connect/protocol";
import type { KnitService } from "@buf/bufbuild_knit.bufbuild_connect-es/buf/knit/gateway/v1alpha1/knit_connect.js";
import {
  DoResponse,
  FetchResponse,
  ListenResponse,
  Request,
  Response,
  Schema,
} from "@buf/bufbuild_knit.bufbuild_es/buf/knit/gateway/v1alpha1/knit_pb.js";
import {
  type Gateway,
  type UnaryAndServerStreamMethods,
  createGateway,
} from "./gateway.js";
import {
  Value,
  MethodKind,
  MethodIdempotency,
  type Message,
  type PartialMessage,
  type ServiceType,
} from "@bufbuild/protobuf";
import { computeSchema } from "./schema.js";
import { applyMask } from "./mask.js";
import { makeOutboundHeader } from "./headers.js";

/**
 * Options accepted by {@link createKnitService}.
 */
export interface CreateKnitServiceOptions<T extends readonly ServiceType[]> {
  /**
   * The transport to use for forwarding requests to endpoints.
   *
   * This can be overridden at the service/method level.
   */
  transport: Transport;
  /**
   * The default timeout in millisecond for RPC calls.
   *
   * This can be overbidden at the service/method level.
   */
  timeoutMs?: number;
  /**
   * The services to expose.
   *
   * @example
   * ```ts
   * createKnitService({
   *   transport: transport,
   *   services: [
   *     {type: ElizaService, methods: ["say"]}
   *   ] as const,
   * })
   * ```
   */
  services: {
    [I in keyof T]: ServiceOptions<T[I]>;
  };
}

/**
 * Options to configure a service in {@link createKnitService}.
 */
export interface ServiceOptions<T extends ServiceType> {
  /**
   * The service type. This is the {@link ServiceType} generated by the
   * connect plugin.
   */
  type: T;
  /**
   * The transport to use for the service. Defaults to the base transport of the router.
   */
  transport?: Transport;
  /**
   * The methods to expose on the service. Defaults to all unary and server streaming methods.
   *
   * Client and Bidi streaming methods are not supported.
   */
  methods?: UnaryAndServerStreamMethods<T>[];
  /**
   * The timeout in millisecond to use for this service.
   */
  timeoutMs?: number;
}

/**
 * Creates the handler for {@link KnitService} that can be used with {@link @bufbuild/connect#ConnectRouter}.
 *
 * @example
 * ```ts
 * export default function (router: ConnectRouter) {
 *   router.service(
 *     KnitService,
 *     createKnitService({
 *       transport: transport,
 *       services: [
 *         {type: ElizaService, methods: ["say"]}
 *       ] as const,
 *     })
 *   );
 * }
 * ```
 */
export function createKnitService<T extends readonly ServiceType[]>({
  transport,
  timeoutMs,
  services,
}: CreateKnitServiceOptions<T>): ServiceImpl<typeof KnitService> {
  const gateway = createGateway({ transport, timeoutMs });
  for (const service of services) {
    gateway.addService(service.type, { ...service });
  }
  return {
    async do({ requests }, { requestHeader }) {
      return new DoResponse({
        responses: await handleUnary(gateway, requests, requestHeader),
      });
    },
    async fetch({ requests }, { requestHeader }) {
      return new FetchResponse({
        responses: await handleUnary(gateway, requests, requestHeader, true),
      });
    },
    async *listen({ request }, { requestHeader }) {
      const iterable = await handleStream(gateway, request, requestHeader);
      for await (const response of iterable) {
        yield new ListenResponse({ response });
      }
    },
  };
}

async function handleUnary(
  { entryPoints }: Gateway,
  requests: Request[],
  requestHeader: Headers,
  forFetch?: boolean
): Promise<PartialMessage<Response>[]> {
  if (requests.length === 0) {
    throw new ConnectError(`No requests provided`, Code.InvalidArgument);
  }
  const outboundHeader = makeOutboundHeader(requestHeader);
  let responses: Promise<PartialMessage<Response>>[] = [];
  for (const request of requests) {
    const entryPoint = entryPoints.get(request.method);
    if (entryPoint === undefined) {
      throw new ConnectError(`Method not found`, Code.NotFound);
    }
    if (entryPoint.method.kind !== MethodKind.Unary) {
      throw new ConnectError(
        `Only unary methods in "Fetch"/"Do"`,
        Code.InvalidArgument
      );
    }
    if (
      forFetch === true &&
      entryPoint.method.idempotency !== MethodIdempotency.NoSideEffects
    ) {
      throw new ConnectError(
        `Only methods with idempotency_level set to NO_SIDE_EFFECTS are allowed in "Fetch"`,
        Code.InvalidArgument
      );
    }
    const schema = computeSchema(
      entryPoint.method.O,
      request.mask,
      request.method
    );
    responses = [
      ...responses,
      entryPoint.transport
        .unary(
          entryPoint.service,
          entryPoint.method,
          undefined, // TODO: Add abort signal if possible.
          entryPoint.timeoutMs,
          outboundHeader,
          entryPoint.method.I.fromJson(request.body?.toJson() ?? {})
        )
        .then(({ message }) => makeResponse(request, schema, message)),
    ];
  }
  return await Promise.all(responses);
}

async function handleStream(
  { entryPoints }: Gateway,
  request: Request | undefined,
  requestHeader: Headers
): Promise<AsyncIterable<PartialMessage<Response>>> {
  if (request === undefined) {
    throw new ConnectError(`No request provided`, Code.InvalidArgument);
  }
  const entryPoint = entryPoints.get(request.method);
  if (entryPoint === undefined) {
    throw new ConnectError(`Method not found`, Code.NotFound);
  }
  if (entryPoint.method.kind !== MethodKind.ServerStreaming) {
    throw new ConnectError(
      `Only server streaming endpoints are allowed in "Listen"`,
      Code.InvalidArgument
    );
  }
  const schema = computeSchema(
    entryPoint.method.O,
    request.mask,
    request.method
  );
  const { message } = await entryPoint.transport.stream(
    entryPoint.service,
    entryPoint.method,
    undefined, // TODO: Add abort signal if possible.
    entryPoint.timeoutMs,
    makeOutboundHeader(requestHeader),
    createAsyncIterable([
      entryPoint.method.I.fromJson(request.body?.toJson() ?? {}),
    ])
  );
  return pipe(
    message,
    async function* (messageIterable) {
      for await (const message of messageIterable) {
        yield makeResponse(request, schema, message);
      }
    },
    {
      propagateDownStreamError: true,
    }
  );
}

function makeResponse(
  request: Request,
  schema: Schema,
  responseMessage: Message
): PartialMessage<Response> {
  return {
    method: request.method,
    body: Value.fromJson(applyMask(responseMessage.toJson(), schema)),
    schema: schema,
  };
}
